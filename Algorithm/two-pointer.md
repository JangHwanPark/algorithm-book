# 학습 목표

---

- 다중 포인터의 개념을 이해하고 설명할 수 있다.
- 두개의 포인터를 사용해 `배열(리스트)`의 양쪽에서 포인터를 조작하여 문제를 해결할 수 있다.
- 한쪽 방향(`left` or `right`)에서 동시에 포인터를 조작하여 문제를 해결할 수 있다.

# 투 포인터 (Two Pointer)

---

`다중 포인터` 또는 `투 포인터`라고 불리는 기법은 흔히 알고리즘이라 부르는 `DFS`나 `BFS` 같은
특정 문제를 해결하는 방법이 아닌, 알고리즘과 자료구조를 이용하여 주어진 문제를 해결하기 위한 일반적인 `접근 방법`이나 `패턴`으로 볼 수 있는데 내 생각에는 소프트웨어 개발에서 `디자인 패턴`과 비슷한 
개념이지 않을까 싶다.

> `알고리즘`은 어떤 문제를 해결하기 위한 명확한 절차나 방법론을 의미한다. (수학 문제를 풀 때 공식을 떠올리면 편하다) 하지만 `패러다임`이나 `디자인 패턴`은 조금 추상적인데 기본적인 틀을 잡아주면 그 
> 안에서 사용자가 자기 입맛대로 유연하게 바꿔가면서 문제를 해결할 수 있다.

`투 포인터`의 개념은 간단한데 우리가 `배열(리스트)`이나 `문자열`에서 요소를 참조하거나 찾을 때 `for`나 `while` 루프를 활용한다.

# 투 포인터 구현과 2가지 유형

---

`투 포인터`기법을 사용하는 기본적인 문제중 하나는 `정렬된 배열`에서 두 수의 합이 특정 값(Target)에 도달하는 첫 번째 쌍을 찾는 문제다. 아래는 투 포인터를 사용하지 않고 쌍을 출력하는 예시다.

```javascript
function sumZero(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] + arr[j] === target) {
                return [arr[i], arr[j]];
            }
        }
    }
}
```
나쁜 방법은 아니지만 위 방법대로라면 시간복잡도는 `O(n^2)`로 입력되는 `데이터`의 크기가 커지면 연산속도가 매우 느려진다.<br>
이때 `투 포인터` 패러다임을 적용하면 `O(n)`의 시간복잡도로 문제를 해결할 수 있다.

`투 포인터`를 구현하기 위해서는 2개의 포인터를 선언해줘야한다.<br>
보통 `for`루프를 사용할때 `초기식`에 사용한 `i`가 포인터가 되어 요소를 순회하는데 `투 포인터`에서는 루프 외부에 `포인터 변수`를 초기화하고 루프 내부에서 `포인터 변수`의 값을 조작하여 `배열
(리스트)`를 순회한다.

> 외부에서 선언하는 `포인터 변수`이름은 보통 `left`, `right`또는 `start`, `end`로 선언한다.

<br>

### 양 끝에서 시작해서 중앙으로 이동하는 두개의 포인터
- 이 방식은 `배열의 양쪽 끝에서 시작`하여 `서로를 향해 중앙으로 이동`하는 `포인터`를 사용하며, 주로 정렬된 배열에서 두 수의 합이 특정 값에 도달하는 문제(예: 합이 0이 되는 두 수 찾기)에 사용된다.
- 조건에 따라 `한 포인터를 오른쪽`으로, `다른 포인터를 왼쪽`으로 이동시켜가며 문제를 해결한다.

```javascript
function twoPointerSum(arr, target) {
    let i = 0; // 시작 포인터
    let j = arr.length - 1; // 끝 포인터

    while (i < j) {
        let sum = arr[i] + arr[j];

        // 목표값에 도달한 경우, 인덱스 쌍을 반환
        if (sum === target) return [i, j];

        // 합이 목표값보다 작은 경우, 시작 포인터를 오른쪽으로 이동
        else if (sum < target) i++;

        // 합이 목표값보다 큰 경우, 끝 포인터를 왼쪽으로 이동
        else j--;
    }

    // 조건을 만족하는 쌍을 찾지 못한 경우
    return [-1, -1]; 
}

const arr = [1, 2, 3, 4, 5];
const target = 9;
twoPointerSum(arr, target); // [3, 4]
```
`twoPointerSum`함수는 `배열(리스트)`의 양쪽 끝에서 부터 `포인터`를 조작하여 타겟을 찾고 타겟을 찾으면 인덱스 쌍을 반환한다.<br>
위 코드를 시각화 하면 다음과 같다.<br>

#### twoPointerSum - Loop1
- i = 0, j = 4
- sum = arr[i] + arr[j] = arr[0] + arr[4] = 1 + 5 = 6

| i |   |   |   | j |
|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 |

**계산**
- i = 0, j = 4, sum = 6 
- if (sum === target) - false 
- else if (sum < target) - true, 따라서 i++
- i가 1로 증가

|   | i |   |   | j |
|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 |

#### twoPointerSum - Loop2
- i = 1, j = 4
- sum = arr[1] + arr[4] = 2 + 5 = 7

**계산**
- i = 1, j = 4, sum = 7 
- if (sum === target) - false 
- else if (sum < target) - true, 따라서 i++
- i가 2로 증가

|   |   | i |   | j |
|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 |

#### twoPointerSum - Loop3
- i = 2, j = 4 
- sum = arr[2] + arr[4] = 3 + 5 = 8

**계산**
- i = 2, j = 4, sum = 8 
- if (sum === target) - false 
- else if (sum < target) - true, 따라서 i++
- i가 3으로 증가

|   |   |   | i | j |
|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 |

#### twoPointerSum - Last Loop
- i = 3, j = 4 
- sum = arr[3] + arr[4]
  - = 4 + 5 = 9

**계산**
- i = 3, j = 4, sum = 9 
- if (sum === target) - true 
- 타겟을 찾았으므로[i, j] = [3, 4]를 반환

<br>

### 한쪽 방향으로 이동하는 두개의 포인터
- `모든 요소`를 `순차적`으로 `탐색`하면서, 특정 조건(예: 합, 최대값 또는 최소값)을 만족하는 최소 또는 최대 길이의 구간을 찾을 때 사용된다.
- `한 포인터(start)는 구간의 시작`을, `다른 포인터(end)는 구간의 끝`을 가리키며, `end 포인터를 이동`시키면서 조건을 만족하는지 확인한 다음, 조건에 따라 `start 포인터를 조절`하여 구간을 조정한다.

한쪽 방향에서 `두 개의 포인터`를 두고 순회하는 기본적인 예제 코드는 아래와 같다.
```javascript
function countUniqueValues(arr) {
    if (arr.length === 0) return 0;
    let i = 0;

    for (let j = 1; j < arr.length; j++) {
        if (arr[i] !== arr[j]) {
            i += 1;
            arr[i] = arr[j];
        }
    }

    return i + 1;
}

let arr = [1, 1, 1, 2, 2, 3];
countUniqueValues(arr);
```
`countUniqueValues`함수는 `배열(리스트)`의 오른쪽 끝에서 `두 개의 포인터`를 조작하여 고유한 값의 개수를 세는 문제를 해결한다.<br>
`i`는 현재 고유 값의 마지막 위치를 가리키는 포인터고, `j`포인터는 배열을 순차적으로 탐색하여 새로운 고유값을 찾는다.

#### countUniqueValues - Loop1
| i | j |   |   |   |   |
|---|---|---|---|---|---|
| 1 | 1 | 1 | 2 | 2 | 3 |
- i = 0, j = 1
- `arr[i]`와 `arr[j]`가 같으므로 j만 이동

<br>

#### countUniqueValues - Loop2
| i |   | j |   |   |   |
|---|---|---|---|---|---|
| 1 | 1 | 1 | 2 | 2 | 3 |
- i = 0, j = 2
- `arr[i]`와 `arr[j]`가 같으므로 j만 이동

<br>

#### countUniqueValues - Loop3
|   | i |   | j |   |   |
|---|---|---|---|---|---|
| 1 | 2 | 1 | 2 | 2 | 3 |
- i = 1, j = 3
- `arr[i]`와 `arr[j]`가 다름
  - i 증가 후 `arr[j]`를 `arr[i]`에 복사

<br>

#### countUniqueValues - Loop4
|   | i |   |   | j |   |
|---|---|---|---|---|---|
| 1 | 2 | 1 | 2 | 2 | 3 |
- i = 1, j = 4
- `arr[i]`와 `arr[j]`가 같으므로 j만 이동

<br>

#### countUniqueValues - Last Loop
|   |   | i |   |   | j |
|---|---|---|---|---|---|
| 1 | 2 | 3 | 2 | 2 | 3 |
- i = 2, j = 5
- `arr[i]`와 `arr[j]`가 다름
  - i 증가 후 `arr[j]`를 `arr[i]`에 복사
  - 배열을 모두 순회했으므로 루프 탈출
- `i`의 `현재 위치(index)`를 반환한다.
  - 배열과 같은 선형 자료구조의 인덱스는 0부터 시작하기때문에 `i + 1`을 반환한다.
  - 고유 값의 개수를 계산할 때는 인덱스가 아니라 개수(요소의 수)를 알고 싶기 때문에, 인덱스로부터 시작하는 0을 고려하여 1을 더한다.